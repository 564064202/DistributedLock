* Consider destructor to avoid the connection pool re-acquisition issue (to avoid the finalizable object in a finalizer issue, we'd have to have the scope
object hold an object which keys into a conditional weak table that holds the transaction)
* Consider providing a hook into when we lose connection to SQL (connection state changed event)
* Consider an option for using distributed transactions w/transaction scope instead of holding connections open (probably bad because we don't know where else the scope will flow)
* Expose security options for event wait handles
* v2 idea: expose ReleaseAsync option by not just returning IDisposable
* v2 idea: use awaitabledisposable pattern for async returns
* v2 idea: remove DbConnection/DbTransaction constructors in favor of just the interface constructors

* 1.2:
	* support IDbConnection/Transaction
	* support .NET Core if we can
	* Rename pooling stuff to "multiplexing"
	* Revamp multiplexing to:
		- be smarter about lock modes (e. g. why not allow multiple of the same shared lock?)
		- use more than one connection: we're going to allocate anyway so we might as well simply allocate as many as we need and free them
			when there are no usages left
	* Document changes via README, publish NuGet